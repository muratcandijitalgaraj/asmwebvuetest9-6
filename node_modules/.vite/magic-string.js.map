{
  "version": 3,
  "sources": ["../sourcemap-codec/src/sourcemap-codec.ts", "../magic-string/src/BitSet.js", "../magic-string/src/Chunk.js", "../magic-string/src/SourceMap.js", "../magic-string/src/utils/guessIndent.js", "../magic-string/src/utils/getRelativePath.js", "../magic-string/src/utils/isObject.js", "../magic-string/src/utils/getLocator.js", "../magic-string/src/utils/Mappings.js", "../magic-string/src/MagicString.js", "../magic-string/src/Bundle.js", "dep:magic-string"],
  "sourcesContent": ["export type SourceMapSegment =\n\t| [number]\n\t| [number, number, number, number]\n\t| [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nconst charToInteger: { [charCode: number]: number } = {};\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfor (let i = 0; i < chars.length; i++) {\n\tcharToInteger[chars.charCodeAt(i)] = i;\n}\n\nexport function decode(mappings: string): SourceMapMappings {\n\tconst decoded: SourceMapMappings = [];\n\tlet line: SourceMapLine = [];\n\tconst segment: SourceMapSegment = [\n\t\t0, // generated code column\n\t\t0, // source file index\n\t\t0, // source code line\n\t\t0, // source code column\n\t\t0, // name index\n\t];\n\n\tlet j = 0;\n\tfor (let i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n\t\tconst c = mappings.charCodeAt(i);\n\n\t\tif (c === 44) { // \",\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\n\t\t} else if (c === 59) { // \";\"\n\t\t\tsegmentify(line, segment, j);\n\t\t\tj = 0;\n\t\t\tdecoded.push(line);\n\t\t\tline = [];\n\t\t\tsegment[0] = 0;\n\n\t\t} else {\n\t\t\tlet integer = charToInteger[c];\n\t\t\tif (integer === undefined) {\n\t\t\t\tthrow new Error('Invalid character (' + String.fromCharCode(c) + ')');\n\t\t\t}\n\n\t\t\tconst hasContinuationBit = integer & 32;\n\n\t\t\tinteger &= 31;\n\t\t\tvalue += integer << shift;\n\n\t\t\tif (hasContinuationBit) {\n\t\t\t\tshift += 5;\n\t\t\t} else {\n\t\t\t\tconst shouldNegate = value & 1;\n\t\t\t\tvalue >>>= 1;\n\n\t\t\t\tif (shouldNegate) {\n\t\t\t\t\tvalue = value === 0 ? -0x80000000 : -value;\n\t\t\t\t}\n\n\t\t\t\tsegment[j] += value;\n\t\t\t\tj++;\n\t\t\t\tvalue = shift = 0; // reset\n\t\t\t}\n\t\t}\n\t}\n\n\tsegmentify(line, segment, j);\n\tdecoded.push(line);\n\n\treturn decoded;\n}\n\nfunction segmentify(line: SourceMapSegment[], segment: SourceMapSegment, j: number) {\n\t// This looks ugly, but we're creating specialized arrays with a specific\n\t// length. This is much faster than creating a new array (which v8 expands to\n\t// a capacity of 17 after pushing the first item), or slicing out a subarray\n\t// (which is slow). Length 4 is assumed to be the most frequent, followed by\n\t// length 5 (since not everything will have an associated name), followed by\n\t// length 1 (it's probably rare for a source substring to not have an\n\t// associated segment data).\n\tif (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);\n\telse if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n\telse if (j === 1) line.push([segment[0]]);\n}\n\nexport function encode(decoded: SourceMapMappings): string {\n\tlet sourceFileIndex = 0;  // second field\n\tlet sourceCodeLine = 0;   // third field\n\tlet sourceCodeColumn = 0; // fourth field\n\tlet nameIndex = 0;        // fifth field\n\tlet mappings = '';\n\n\tfor (let i = 0; i < decoded.length; i++) {\n\t\tconst line = decoded[i];\n\t\tif (i > 0) mappings += ';';\n\t\tif (line.length === 0) continue;\n\n\t\tlet generatedCodeColumn = 0; // first field\n\n\t\tconst lineMappings: string[] = [];\n\n\t\tfor (const segment of line) {\n\t\t\tlet segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n\t\t\tgeneratedCodeColumn = segment[0];\n\n\t\t\tif (segment.length > 1) {\n\t\t\t\tsegmentMappings +=\n\t\t\t\t\tencodeInteger(segment[1] - sourceFileIndex) +\n\t\t\t\t\tencodeInteger(segment[2] - sourceCodeLine) +\n\t\t\t\t\tencodeInteger(segment[3] - sourceCodeColumn);\n\n\t\t\t\tsourceFileIndex = segment[1];\n\t\t\t\tsourceCodeLine = segment[2];\n\t\t\t\tsourceCodeColumn = segment[3];\n\t\t\t}\n\n\t\t\tif (segment.length === 5) {\n\t\t\t\tsegmentMappings += encodeInteger(segment[4] - nameIndex);\n\t\t\t\tnameIndex = segment[4];\n\t\t\t}\n\n\t\t\tlineMappings.push(segmentMappings);\n\t\t}\n\n\t\tmappings += lineMappings.join(',');\n\t}\n\n\treturn mappings;\n}\n\nfunction encodeInteger(num: number): string {\n\tvar result = '';\n\tnum = num < 0 ? (-num << 1) | 1 : num << 1;\n\tdo {\n\t\tvar clamped = num & 31;\n\t\tnum >>>= 5;\n\t\tif (num > 0) {\n\t\t\tclamped |= 32;\n\t\t}\n\t\tresult += chars[clamped];\n\t} while (num > 0);\n\n\treturn result;\n}\n", "export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}", "export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext:     { writable: true, value: null }\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n", "import { encode } from 'sourcemap-codec';\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = str => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = str => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n", "export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter(line => /^\\t+/.test(line));\n\tconst spaced = lines.filter(line => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n", "export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n", "const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n", "export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n", "export default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n", "import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal:              { writable: true, value: string },\n\t\t\toutro:                 { writable: true, value: '' },\n\t\t\tintro:                 { writable: true, value: '' },\n\t\t\tfirstChunk:            { writable: true, value: chunk },\n\t\t\tlastChunk:             { writable: true, value: chunk },\n\t\t\tlastSearchedChunk:     { writable: true, value: chunk },\n\t\t\tbyStart:               { writable: true, value: {} },\n\t\t\tbyEnd:                 { writable: true, value: {} },\n\t\t\tfilename:              { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations:    { writable: true, value: new BitSet() },\n\t\t\tstoredNames:           { writable: true, value: {} },\n\t\t\tindentStr:             { writable: true, value: guessIndent(string) }\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext(chunk => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach(exclusion => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = match => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error('Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead');\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tthis.storedNames[original] = true;\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tif (end > first.end && first.next !== this.byStart[first.end]) {\n\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\n\t\t\tif (first !== last) {\n\t\t\t\tlet chunk = first.next;\n\t\t\t\twhile (chunk !== last) {\n\t\t\t\t\tchunk.edit('', false);\n\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length)\n\t\t\treturn this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length)\n\t\t\t\treturn chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length)\n\t\t\t\treturn chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length)\n\t\t\t\treturn chunk.intro[chunk.intro.length - 1];\n\t\t} while (chunk = chunk.previous);\n\t\tif (this.intro.length)\n\t\t\treturn this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1)\n\t\t\treturn this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1)\n\t\t\t\t\treturn chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while (chunk = chunk.previous);\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1)\n\t\t\treturn this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} \u2013 \"${\n\t\t\t\t\tchunk.original\n\t\t\t\t}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (chunk.intro.length && chunk.intro.trim() ||\n\t\t\t\t\tchunk.content.length && chunk.content.trim() ||\n\t\t\t\t\tchunk.outro.length && chunk.outro.trim())\n\t\t\t\treturn false;\n\t\t} while (chunk = chunk.next);\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while (chunk = chunk.next);\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n}\n", "import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach(option => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || ''\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator\n\t\t});\n\n\t\tthis.sources.forEach(source => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach(source => {\n\t\t\tObject.keys(source.content.storedNames).forEach(name => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext(chunk => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map(source => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map(source => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach(source => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty () {\n\t\tif (this.intro.length && this.intro.trim())\n\t\t\treturn false;\n\t\tif (this.sources.some(source => !source.content.isEmpty()))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce((length, source) => length + source.content.length(), this.intro.length);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n", "import d from \"./node_modules/magic-string/dist/magic-string.es.js\";export default d;\nexport * from \"./node_modules/magic-string/dist/magic-string.es.js\""],
  "mappings": "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",
  "names": []
}
